<?php
/**
 * Author: Ted Bowman
 * Date: 8/23/15
 * Time: 11:45 AM
 */

namespace Drupal\block_groups\Plugin\Condition;


use Drupal\Core\Condition\ConditionPluginBase;
use Drupal\Core\Entity\EntityStorageInterface;
use Drupal\Core\Executable\ExecutableManagerInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
use Drupal\Core\Plugin\Context\ContextHandlerInterface;
use Drupal\Core\Plugin\Context\ContextRepositoryInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * Provides a 'Condition Group' condition.
 *
 * @Condition(
 *   id = "condition_group",
 *   label = @Translation("Condition Group"),
 * )
 */
class ConditionGroup extends ConditionPluginBase implements ContainerFactoryPluginInterface{

  /**
   * The condition plugin manager.
   *
   * @var \Drupal\Core\Executable\ExecutableManagerInterface
   */
  protected $manager;

  /**
   * The plugin context handler.
   *
   * @var \Drupal\Core\Plugin\Context\ContextHandlerInterface
   */
  protected $contextHandler;

  /**
   * The context manager service.
   *
   * @var \Drupal\Core\Plugin\Context\ContextRepositoryInterface
   */
  protected $contextRepository;

  /**
   * The entity storage.
   *
   * @var \Drupal\Core\Entity\EntityStorageInterface
   */
  protected $entityStorage;

  /**
   * Evaluates the condition and returns TRUE or FALSE accordingly.
   *
   * @return bool
   *   TRUE if the condition has been met, FALSE otherwise.
   */
  public function evaluate() {
    // TODO: Implement evaluate() method.
  }

  /**
   * Provides a human readable summary of the condition's configuration.
   */
  public function summary() {
    // TODO: Implement summary() method.
  }

  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
    $block_groups = $this->entityStorage->loadMultiple();
    foreach ($block_groups as $type) {
      $options[$type->id()] = $type->label();
    }
    $form['block_group'] = array(
      '#title' => $this->t('Block Groups'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => $this->configuration['block_group'],
    );
    $form = parent::buildConfigurationForm($form, $form_state); // TODO: Change the autogenerated stub
    $form['negate']['#access'] = FALSE;
    return $form;
  }



  /**
   * Creates an instance of the plugin.
   *
   * @param \Symfony\Component\DependencyInjection\ContainerInterface $container
   *   The container to pull out services used in the plugin.
   * @param array $configuration
   *   A configuration array containing information about the plugin instance.
   * @param string $plugin_id
   *   The plugin ID for the plugin instance.
   * @param mixed $plugin_definition
   *   The plugin implementation definition.
   *
   * @return static
   *   Returns an instance of this plugin.
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static(
      $container->get('entity.manager')->getStorage('block_group'),
      $container->get('plugin.manager.condition'),
      $container->get('context.handler'),
      $container->get('context.repository'),

      $configuration,
      $plugin_id,
      $plugin_definition);
  }

  public function __construct(EntityStorageInterface $entity_storage, ExecutableManagerInterface $manager, ContextHandlerInterface $context_handler, ContextRepositoryInterface $context_repository, array $configuration, $plugin_id, $plugin_definition) {
    parent::__construct($configuration, $plugin_id, $plugin_definition); // TODO: Change the autogenerated stub
    $this->manager = $manager;
    $this->contextHandler = $context_handler;
    $this->contextRepository = $context_repository;
    $this->entityStorage = $entity_storage;
  }

}
